# ===================================================
# Exercise 2: Unfair Dice
# ===================================================
# Name: Ryan Sandoval
# ID: 1529017
# Course: CMPUT 274, FALL 2018

import random

# Debug Flag
DEBUG = False


def biased_rolls(prob_list, s, n):
    """ Simulate n rolls of a biased m-sided die and return
    a list containing the results.

    Arguments:
        prob_list: a list of the probabilities of rolling the
                   number on each side of the m-sided die. The list
                   will always have the length m (m >= 2), where m is
                   the number of sides numbered 1 to m. Therefore,
                   for example, the probability stored at index 0 in
                   the list is the probability of rolling a 1 on
                   the m-sided die.
        s: the seed to use when initializing the PRNG
        n: the number of rolls to return

    Return:
        rolls: a list (of length n) containing each of the n rolls of the
               biased die, in the order they were generated.
    """

    # Init
    # ====
    random.seed(s)
    rolls = []

    # Value Checking
    # ==============

    if (len(prob_list) < 2):
        raise ValueError("`prob_list` must have 2 or more elements")

    # Create rolls list
    # ==================

    for _ in range(n):
        acc = 0  # Accumulator
        roll = random.random()

        # NOTE that after each iteration, it is guranteed that:
        # num > the previous value of acc. Thus, this `for loop`
        # maps a number to a region in range [0,1) which in turn
        # is mapped to a die side
        for index, prob in enumerate(prob_list):
            acc += prob
            if roll < acc:
                rolls.append(index + 1)
                break

    if DEBUG:
        print("*Generated Rolls: \n{}".format(rolls))
        print("*List Length: {}".format(len(rolls)))
        assert len(rolls) == n, "Incorrect number of rolls generated"

    # return the resulting rolls
    # ==========================
    return rolls


def draw_histogram(m, rolls, width):
    """ Draws a frequency histogram of the rolls of an m-sided die
    mapped to a fixed width.

    Arguments:
        m (int): the number of sides on the die
        rolls (list): the list of rolls generated by the biased die
        width (int): the fixed width of the histogram, in characters
                     (this is the length of the longest bar in the
                     histogram, to maximize space in the chart)

    Returns:
        None (but prints the histogram to standard output)
    """

    # Value Check
    # ===========

    if width < 0:
        raise ValueError("Width must be zero or greater")

    if max(rolls) > m or min(rolls) < 1:
        raise ValueError("Rolls contains an invalid roll value")

    # Init
    # ====

    # Historgam to print at end of program. Already Includes Title
    histogram = "Frequency Histogram: {}-sided Die\n".format(m)

    # Contains the total rolls for each side of the die. Die side is index + 1
    barData = []

    # Sum Roll Data
    # =============

    for side in range(1, m + 1):
        count = rolls.count(side)
        barData.append(count)

    maxRollCount = max(barData)

    # Create the chart
    # ================

    for index, side in enumerate(range(1, m + 1)):
        # Ratio of current bar and the longest bar
        barRatio = barData[index] / maxRollCount

        # Generate bar and filler through repetition
        bar = "*" * round(barRatio * width)
        filler = "." * round(width - (barRatio * width))

        histogram += ("{}:{}\n").format(side, bar + filler)

        if DEBUG:
            histogram += "Bar: {} Filler: {} Total: {}\n".format(
                len(bar), len(filler), len(bar + filler)
            )

    # Print the historgram
    # ====================

    print(histogram.strip()) # Also strips newline char at end of graph


if __name__ == "__main__":
    # Any code indented under this line will only be run
    # when the program is called directly from the terminal
    # using "python3 unfairDice.py". This can be useful for
    # testing your implementations.
    draw_histogram(2, [], 5)
    pass
